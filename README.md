# JVM原理

JVM：java虚拟机，将编写的程序翻译成操作系统能运行的格式。对应不同的操作系统有对应的JVM，只要将java代码经过java编译器编译成.class文件就可以让JVM识别并在对应系统下运行。（这就是为什么java只用编译一次就可以在各个地方运行，**字节码可以在不同操作系统上运行，只要有对应的JVM**）

day 1

****

## JVM生命周期

JVM在程序开始运行的时候就开始运行，在所有程序停止运行时停止运行。

一个java程序对应一个JVM进程。

JVM线程分为普通线程和守护线程

> java程序就是普通线程
>
> 守护线程是一种特殊的线程，守护线程一般是管理后台任务，例如垃圾回收（GC），内存管理。
>
> **守护线程依赖于JVM生命周期，当JVM结束时不管守护线程有没有在运行都会随着JVM一同结束。**
>
> **因此守护线程不应该用来执行一些重要的任务或程序，因为守护线程的声明周期不可控，避免发生资源泄露（程序异常停止，且没有类似于手动释放资源的操作）或者数据不一致**
>
> 可以通过Thread类的`setDaemon(true)`方法将线程标记为守护线程

只要JVM中有普通线程在运行JVM就不会停止

**结束JVM生命周期：**
执行System.exit()

程序正常结束

程序在执行的过程中出现异常或者出错导致进程终止

操作系统出现异常导致java虚拟机进程终止

## JVM结构体系

### JDK，JRE，JVM

JDK提供了开发环境和运行环境，而运行环境就是JRE（java运行环境）,JRE中包含了JVM（java虚拟机）

JVM结构体系：

![image-20231012162932459](C:\Users\kilok\AppData\Roaming\Typora\typora-user-images\image-20231012162932459.png)

### Java类文件：.Class文件

**.java文件只有被java编译器编译为.class文件才能被JVM识别运行。**

**.class文件不是操作系统能够识别的二进制机器码，而是JVM自定义的指令集，只要对应的操作系统有对应的JVM，就能将.class文件翻译成操作系统能够识别的机器码。**

> .class文件事宜特定的二进制格式存储的，这个格式包含了Java源代码编译后的 **字节码指令，常量池，字段信息，方法信息以及其他类的结构信息**
>
> > **组成**
> >
> > **1.魔数**：.class文件开头的四个字节是一个魔数，通常为‘0xCAFEBABE’，**这用于表示这个.class文件是一个有效的java类文件**
> >
> > **2.版本信息：**紧随魔数后的两个字节是文件的版本信息，包含主版本号和次版本号，**用于标识编译器和JVM的版本兼容性**
> >
> > **3.常量池：**常量池是一个表格，包含一系列的常亮信息，如字符串的字面量，类的接口名，字段和方法的符号引用，字面常量。**常量池用于支持字节码中的各种操作，包括字段访问，方法调用，类的初始化。**
> >
> > **4.访问标志：**表示该类的访问权限，public final abstract等等
> >
> > **5.类，父类，接口信息：**包含类的名称，父类的名称和方法的实现
> >
> > **6.字段表：**字段表包含了类的字段信息，**字段名，类型和访问标志**
> >
> > **7.方法表：**包含了类的方法信息，**方法名称，参数列表，返回类型，访问标志等**
> >
> > **8.属性表：**属性表包含了与类，字段，方法等相关的额外信息。**包括了调试信息，注解，泛型信息等**
> >
> > **9.字节码：**.class文件中主要部分就是字节码，这是一系列字节码指令，用于定义类中方法的操作。**这些指令包括加载，储存，算术运算，方法调用，条件分支等**
> >
> > **10.异常处理表：** **异常处理表用于指定异常处理开始和结束的地方，以及异常处理的类型**
>
> .class文件是紧凑的，二进制的，它包含了类的结构和行为信息，以支持JVM的加载，验证，解析和执行。JVM解析.class文件时会按照这个结构解析和执行其中的字节码，这种设计使得只要遵循这种设计不管在哪个操作系统的JVM下都可以被解析运行。

#### 字节码

**字节码是由java源码编译而来的，不同于机器码，字节码是一种中间码，不直接在硬件上运行，保证了字节码的跨平台性和安全性**

> **中间代码：**不同于源码和机器码，介于它们之间。
>
> **跨平台性：**java字节码是可以移植的， 可以在不同的操作系统环境下运行，只要有对应的JVM运行环境。
>
> **安全性：**字节码是一种中间表示，不同与机器码字节码不容易被直接修改吗，提高了java应用程序的安全性。
>
> **动态性：**字节码可以动态加载和生成，为动态类加载，热部署，翻身和动态代理等功能提供了基础
>
> **性能：**虽然字节码解释执行比本地机器码要慢，但是JVM可以通过即时编译（Just-In-Time-Compilation）将字节码编译成本地机器码，以提高性能。

### 类加载子系统

**类加载器是JVM中一个关键组成部分，类加载器负责将.class文件加载成可执行的字节码**

**类加载子系统的主要任务：**

> **类加载**
>
> **链接**
>
> **初始化**
>
> **验证**

#### 类加载器：

> **类加载器主要将.class文件加载到内存中，并转化为java类数据结构**
>
> 主要的类加载器：
>
> > **引导类加载器（Bootstrap Class Loader）启动类加载器，最顶层的类加载器，负责加载JDK中的核心类库**
> >
> > **扩展类加载器（Extension Class Loader）负责加载扩展的类库（依赖），默认加载java的系统路径 $JAVA_HOME中jre/lib/*.jar或者指定的jar包**
> >
> > **应用程序类加载器（Application Class Loader）系统类加载器，负责加载应用程序Classpath目录下的所有jar和.class文件**
> >
> > **除了Bootstarp Class Loader之外，其他加载器都是继承于java.lang.ClassLaoder，因为Bootstarp Class Loader底层是由C++实现，并嵌入到JVM里。当JVM启动时，BootStarp Class Loader就会启动负责加载核心库类，并加载 Extension Class Loader和Application Class Loader两个加载器**
> >
> > 以上三个加载器是java提供的加载器，我们还可以根据自己的需求自己定义加载器，但是必须继承于java.lang.ClassLoader类
>
> 类加载器的主要功能是：
>
> > **1.查找类文件**
> >
> > 当java程序需要使用到某个类时，会先检查内存中是否已经有看这个类，否则类加载器就会进行一个查找的步骤，查找对应的类文件，其中涉及到了类加载路径（Classpath）的搜索，Classpath中包含了可以加载类文件（.class）的目录（这个目录是一个指向包含类文件地址的文件夹，这些目录的结构按照包名来组织）和JRE文件（这里的JRE是压缩格式，可以包含多个类文件和资源文件）。不同的类加载器会搜索不同的位置
> >
> > **2.加载类文件**
> >
> > 当类加载器找到对应的类文件（.class文件）时会将这个.class文件加载为二进制数据，这个二进制数据就包含了对应类的字节码，字节码（一组字节组成的指令）描述着这个类的结构和行为。最后将这些二进制数据加载进内存中。
> >
> > **3.创建类对象**
> >
> > 一旦类的二进制数据加载进了内存中，那么类加载器会根据这个数据创建一个java类的对象，其中包含着这个类的所有信息（父类，接口，字段，构造方法.....）
> >
> > **4.链接**
> >
> > 在加载完类后，类加载器还会进行链接的步骤（包含验证，准备和解析）为了保证我文件的3完整性，合法性和正确性。
> >
> > > **验证：**
> > >
> > > 类加载器会验证加载出的.class文件的字节码是否符合java虚拟机（JVM）的规范
> > >
> > > 包括文件格式的验证，确认二进制结构是有效的，遵循java字节码规范
> > >
> > > 语义验证，是否符合java语言规则
> > >
> > > 字节码验证：检查字节码是否符合JVM安全规则
> > >
> > > **准备：**
> > > 在准备阶段类加载器会为静态变量分配内存，并初始化为默认值。静态变量分配内存是发生在类加载时，而不是类实例化时。
> > >
> > > **解析：**
> > >
> > > > **类或接口解析：JVM会解析类或接口的全限定名，以此来获取对应的类或接口** （类的全限定名是类的唯一标识符例如java.lang.String 是String的唯一标识符，类的权限定名的作用：在大型项目下，不同包里面可能会有相同的类名，而权限定名可以直接区分他们，同理方法的全限定名和包的全限定名）
> > >
> > > > **字段解析：解析类的字段引用，以此获得字段的内存地址**
> > >
> > > > **方法解析：解析方法引用，以此获得方法的入口**
> > >
> > > **初始化类：**
> > > 初始化类时类加载器的最后一阶段，执行类里面的构造方法，初始化类的静态字段。在类的初始化完成后，就可以进行类的实例化，字段可以访问，方法可以被调用
> > >
> > > **类的卸载：**一些加载器支持类的卸载，当类不在别引用时就会别卸载。

### 方法区（Method Area）

**方法区是JVM内存管理中的重要一部分**

**储存类的所有信息（结构信息，元数据）（字段，方法，.....），还可以支持类的加载，初始化和方法调用，字段访问等**

> **1.储存类信息：**
>
> java方法区会储存已经加载的类的信息，包括类名（全限定名），结构，字段，方法，构造函数，父类，接口.....，当这些信息储存在方法区，方便运行时访问和使用（这样储存类的信息就是类的符号引用，符号引用：用来描述类的结构和行为，符号引用并不会直接储存或指向一个内存地址，而是在JVM根据需要时根据符号引用查找对应的类和对应的结构，字段，方法，父类，接口...等实际运行的数据，**而且类的符号引用不是储存在字节码的具体指令，而是存储在.class文件里的元数据，描述类的结构和行为，以支持类的动态加载和运行时的解析，类的符号引用是以一种包含文本信息和结构化数据的格式存储，里面包含有类名，字段描述，方法描述，常量池索引等**）
>
> **2.静态变量：**
>
> java方法区还会储存类的静态变量，这些静态变量在被加载时就初始化了。静态变量的声明周期和类的生命周期一致。
>
> **3.常量池：**常量池是一个表格，包含有各种常量（类名，方法名，字段名，字符串文字，方法句柄），符号引用，字面量常量（字符串）,字段和方法的描述。**常量池用于支持字节码的操作（其他常量）字段的访问或方法的调用，类的初始化等。**（**常量池在java文件中时一次性加载的，有助于调高系统性能，一旦加载完成，就不需要再进行解析或加载**）
>
> **4.方法字节码：**java方法区用于储存字节码的地方，**支持类的运行时常量池，字段的访问，方法的调用，逻辑操作，算术运算等**
>
> **5.内存管理：**方法区的内存管理和java堆区的内存管理不一样。方法区的内存是加载类时动态分配的内存，而在类卸载时释放，方法区的内存管理由JVM控制，垃圾回收机制负责回收不再使用的类或常量池中的数据。
>
> **6.运行时常量池：**除了常量池JVM还维护了一个运行时常量池，**它包含有常量池的部分内容，支持运行时的字符串拼接，反射和动态代理机制**
>
> **7.永久代和元空间：**在JDK8之前方法区的实现方法是永久代，之后都是元空间，元空间会在运行时动态调整，只要不超过当前内存上线，就不会发生溢出的问题。
>
> 

**方法区的信息的生命周期通常不变，但是在特定情况下（类不在被引用）会将类卸载**



### Java堆区

**Java堆区是JVM中存放对象实例和数组的地方，是java分配和管理对象的主要区域，也是运行时动态分配内存的地方（内存管理->垃圾回收机制）**

> **1.内存分配：**Java堆区是存放运行时所创建的对象的地方。当创建一个新的对象吗，内存会从堆区中分配出来。堆区的内存分配是动态的。
>
> **2.对象生命周期：**对象在堆区中分配内存后，会一直存在，除非不在引用，或者引用变为null，然后又垃圾回收负责回收哪些不在使用的对象。对象的生命周期也是不确定的。
>
> **3.堆区分代：**堆区有不同的分代，有新生代和老年代，新生代就是刚刚创建不久的对象，而老年代就存放着，创建很久并且还在引用的对象（存活时间较长的对象）。这种分代策略有助于垃圾回收的效率，因为不同代的对象具有不同的生命周期特点。
>
> **4.垃圾回收：**当堆区的对象不在被引用或者引用为null时，会由JVM的；垃圾回收将这些对象所占用的内存释放，以便供给为创建的新对象分配内存。**垃圾回收的机制就是追踪堆区中不被引用的对象，并释放他们的内存。**
>
> **5.堆区的大小：**堆区的大小可以通过修改配置文件，或命令行来修改。如果堆区过小则会报错：OutMemoryError，堆区过大则会浪费内存资源。
>
> **6.内存管理策略：**堆区中的内存管理策略通常是分代垃圾回收策略，新生代的对象和老年代对象通过不同的垃圾回收算法进行跟踪释放资源。新生代通常是复制算法，而老年代通常使用标记-清除算法或标记整理算法。
>
> > **复制算法：**
> >
> > 原理：将内存分为两块，**from和to空间**，在垃圾回收的过程中，将form空间中存活的对象复制到to空间中，然后释放from空间的内容，而to空间就只存在存活的对象。这个算法用于新生代的对象。
> >
> > 优点：这个算法快速且高效，适用于处理打来那个的瞬时对象，可以有效减少内存碎片。
> >
> > 缺点：会经过多次复制，还多使用了一个to的内存空间，不适用与长时间存活的对象。
> >
> > **标记-清除算法**
> >
> > 

#### 垃圾回收的作用

> **内存管理：**有效管理内存，避免内存的泄露或者浪费，高效使用内存
>
> **提高卡法效率：**不用手动去分配内存，全都是通过垃圾回收实现。
>
> **动态分配内存：**由垃圾回收机制实现堆区的动态分配和回收，不会溢出或者浪费内存资源。
>
> **提高性能：**通过选择合适的垃圾回收机制（算法），可以提高系统的性能能
>
> **支持大规模应用：**垃圾回收机制允许java程序处理大量的对象，而不会出现内存不足或者浪费资源的情况。



day  2

****

### 虚拟机栈（JVM栈）

**栈是一种先进后出的数据结构**

**JVM栈用于方法的递归和和管理方法的执行**

> **JVM栈的产生：**JVM的栈是每一个线程的私有区域（对应线程的栈不能被其他线程访问），当一个线程创建运行时，一个对应的栈也就建立了。
>
> **JVM栈的作用：用于储存方法调用的局部变量，返回信息，操作数栈，以及一些额外的辅助信息；线程在执行方法时都会在JVM栈中创建一个栈帧，栈帧包含了方法调用的信息**
>
> **栈帧：**
>
> > **局部变量区：**方法内部的基本变量，实例对象的引用
> >
> > **操作数栈区：**执行方法的计算，并存放执行过程中产生的中间结果
> >
> > **方法返回地址：**执行完方法后要返回的地址
> >
> > **运行时常量池引用：**指向当前方法的常量池，用于解析符号引用。
>
> **方法的调用：**当前线程执行方法时会新建一个栈帧，并将参数传进局部变量，执行方法体。方法执行完成后会弹出栈帧，并返回上一个栈帧。
>
> **栈的深度：**栈的深度（大小）在JVM启动的时候就已经分配好，如果超过栈的深度，则会报错StackOverflowError，如果栈的深度扩展失败则会报错OutOfMemoryEoor
>
> **栈帧的生命周期：**栈帧的生命周期和方法调用的生命周期一样，当方法调用完成后，会弹出并销毁栈帧，释放内存。
>
> JVM栈是私有的，不会被共享，有助于线程安全和避免竞态条件。
>
> > **竞态条件（Race Condition）：**是多线程编程中一种常见但是不想遇到的情况，竞态条件发生在多个线程同时访问一个资源时，到时程序出现不确定性的错误。竞态条件多数发生在多个线程并发和无序性引起，导致不可预测的结果。
> >
> > 当多个线程同时要修改一个资源时，由于不可定的顺序和时间，通常会导致以下问题：
> >
> > > **数据不一致：**当多个线程同时修改一个资源的数据时，会导致每个线程所得到的数据可能不一致，与预期不符。
> > >
> > > **死锁：**竞态条件可能会导致线程之间相互等待，导致形成死锁（线程永远阻塞）。
> > >
> > > **资源竞争：**多个线程共享（竞争）资源，会导致性能下降和资源浪费。
> > >
> > > **非确定性行为：**竞态条件由于多个线程的顺序和时间的不确定性，可能会导致程序的行为不可预测（结果同样不可预测），出现难以复现的错误和异常情况。

### 本地方法栈

本地方法栈（Native Method Stack）也是JVM栈的一部分，本地方法栈由c,c++实现，主要处理执行本地的方法，并与（底层操作系统）硬件交互，提供了JVM与外部资源交互的接口。

> **本地方法：**本地方法是用本地编程语言编写的方法，通常包含了本地的库，操作系统或硬件资源的代码。java通过本地方法接口，使得java程序可以调用本地的方法。
>
> **本地方法栈：**与JVM栈类似，每一个线程有属于自己的本地方法栈，本地方法栈管理的是本地方法的栈帧。
>
> **栈帧：**与JVM栈的栈帧相似
>
> **本地方法调用：**线程要调用本地方法时，java会将控制权交给本地方法栈，待本地方法执行完后将控制权返回给java程序。
>
> **本地方法库：**本地方法放在本地方法库中，由外部编程语言编写的二级制库。JVM通过JNI调用本地方法库中的方法。
>
> 本地方法栈也会在深度溢出或扩展失败的时候，分别抛出StackOverflowError 和 OutOfMemoryError 异常。

本地方法通常用于处理系统底层资源，文件操作，网络通信，图形界面或者与硬件设备进行交互。使用本地方法时需要谨慎，因为本地方法可以绕过Java的内存管理和安全性特性，使用时需要保证本地方法的正确性和安全性。



## JVM中栈和堆的比对

### JVM栈

> **栈是用来存储局部变量和方法的数据区域，每一个线程都有自己的栈**
>
> **栈中存放的包括局部变量，方法的参数和方法的返回信息。这些数据的生命周期和栈的声明周期相同**
>
> **栈的内存管理非常高效，不需要垃圾回收机制，因为栈是线程私有的**
>
> **逃逸分析可以确定某些对象是否会逃逸到方法之外（指这个对象只会在这个方法中使用），如果对象不会逃逸到方法之外，JVM引擎就会优化将这个对象的内存分配到栈中而不是堆上。**

### Java堆

> **堆是用来存放对象实例的数据区域，所有线程共享一个堆**
>
> **堆中所存放的对象实例的生命周期不受方法调用的影响（限制）**
>
> **堆区的内存管理涉及垃圾回收，不再引用的对象的内存空间会被回收**



### 程序计数器（PC寄存器）



**程序计数器（Program Counter）：用于跟踪当前线程执行字节码指令的地址**



> **作用：**用于储存当前线程执行字节码的地址，并指导线程执行下一步。
>
> **线程私有：**由于有时候会存在多线程上下文切换，为了保证线程切换回来的时候能够明确下一步需要执行的字节码地址，每一个线程都有一个自己私有的Program Counter，就是为了保证线程切换回来时立马能够执行下一个指令，不受其他线程干扰。
>
> **字节码指令：**程序计数器中包含了当前线程所执行的字节码的地址。
>
> **方法调用和返回：**程序计数器中存储了方法的返回地址，当方法执行完后，返回时，程序计数器可以继续指导线程继续执行方法调用者的字节码指令。
>
> **循环和分支：**程序计数器同样管理程序的循环和分支结构；在执行循环语句时，计数器会不断更新以知道循环体内的字节码指令执行；在分支结构中，计数器决定了程序的分支路径。
>
> **线程切换：**当程序切换线程时，计数器会指导线程继续执行刚才中断的地方。
>
> **线程安全：**程序计数器不会涉及内存管理和对象状态，因此不会导致线程安全问题。

**程序计数器的开销很小，因为只用存储字节码的指令地址，通常为整数型寄存器，只占JVM内存的很小一部分区域**

**Program Counter 只占内存区域的很小一部分，跟踪线程执行位置，不涉及内存管理和对象状态；私有，是java线程执行的引导。**

#### 程序执行顺序：

java程序启动的入口方法就是 public static void  main(String[] args) ,当启动程序时，JVM会查找参数为String且方法名为main的方法，以此作为程序开始的起点。

在执行main方法之前JVM会先在对应线程的JVM栈中创建一个栈帧（Stack Frame） ，栈帧包含了局部变量表，操作数栈和方法返回地址等。

JVM开始执行main里面的方法，这些方法对应着自己的Java字节码

当main调用其他方法，JVM会创建一个新的栈帧，当方法执行结束，将结果返回给main并继续执行main里面的方法。（执行其他方法，将控制权转移给对应的方法，方法执行结束归还控制权）

程序执行结束，JVM关闭。

**程序计数器在其中的作用**

> **方法调用指令：**程序计数器储存了当前线程执行方法的字节码的地址。指导要跳转到哪个方法的字节码指令地址。
>
> **方法返回地址：**当调用的方法执行结束后，程序计数器会指导JVM将控制权返回给调用者（对应方法的字节码地址）
>
> **控制流管理：**程序计数器在方法调用和返回值帮助控制流管理。指导了线程的执行位置（字节码的地址），确保方法能够被正常调用和返回，以此字节码执行顺序。
>
> **线程独立性：**每个线程之间的程序计数器相互独立，不会相互干扰，每个线程都能够正确的跟踪自己执行字节码的位置。
>
> **异常处理：**当异常出现时，程序计数器可以确定异常处理程序的入口，以便执行适当的异常处理代码。

​        

### JVM执行引擎

**JVM执行引擎是 JVM的核心组件之一，JVM执行引擎的主要作用就是执行Java字节码指令（将指令集翻译成硬件所支持的指令集），实际运行程序逻辑。**

> **字节码解释：**JVM执行引擎会将字节码翻译成虚拟机或者本地机器能够执行的指令。通过这种方法，java程序就可以在不同平台上运行。
>
> **执行引擎的执行方式**
>
> > **解释执行：**这是执行引擎最基本的执行方式，执行引擎会通过解释器逐条解释，之后子再执行字节码指令。这意味着每一条字节码指令都需要在运行的时候被解释和执行，这样的执行速度通常很慢。
> >
> > **编译执行（JIT编译，即时编译）：**为了提高性能，JVM引入了即时编译起（Just-in-Time Compiler JIT），即时编译器会将热点代码（经常执行的代码）编译成本地的机器码，从而加速执行。编译后的代码会被缓存，以便多次使用，解决了执行的性能开销。
>
> **栈帧：**执行引擎会调用栈帧来管理方法的执行。
>
> **方法调用：**执行引擎负责方法的调用和返回。
>
> **异常处理：**执行引擎也负责捕获和处理异常。当异常发生时，执行引擎会在栈帧之间传递信息，查找适当的异常处理器，并执行相应的异常处理代码。
>
> **多线程支持：**JVM执行引擎需要支持多线程，因为每一个线程都有自己的java程序和栈帧。确保线程之间独立运行。
>
> **性能优化：**执行引擎通常会进行性能优化，例如方法内联，逃逸分析，循环优化，以提高程序的执行速度（JIT就是性能优化的其中一个）
>
> **安全性和类的加载检查：**JVM引擎就是执行类加载系统的链接，验证和初始化操作，确保Java程序的安全性和正确性。

**JVM执行引擎的性能优化：**

> **即时编译（编译执行）：**通过将热点代码编译成本地机器码并缓存，方便之后的多次使用，极大程度上减少了程序执行的开销。
>
> **方法内联：**执行引擎会将热点代码进行内联，将被调用方法嵌入到调用方法中，减小了方法调用时的开销。（这有助于减小堆栈（栈帧）深度，提高性能）。
>
> **逃逸分析：**逃逸分析会确定对象是否会逃逸到方法之外，如果对象只在方法之内调用，那么JVM执行引擎就不会将这个对象的实例内存分配到堆上，就直接分配到栈里，直接供栈内的方法调用。
>
> **循环优化：**：JIT编译器可以优化循环，例如展开循环，消除无用循环，以减少循环的开销，提高执行效率。

