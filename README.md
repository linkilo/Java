# JVM原理

JVM：java虚拟机，将编写的程序翻译成操作系统能运行的格式。对应不同的操作系统有对应的JVM，只要将java代码经过java编译器编译成.class文件就可以让JVM识别并在对应系统下运行。（这就是为什么java只用编译一次就可以在各个地方运行）

## JVM生命周期

JVM在程序开始运行的时候就开始运行，在所有程序停止运行时停止运行。

一个java程序对应一个JVM进程。

JVM线程分为普通线程和守护线程

> java程序就是普通线程
>
> 守护线程是一种特殊的线程，守护线程一般是管理后台任务，例如垃圾回收（GC），内存管理。
>
> **守护线程依赖于JVM生命周期，当JVM结束时不管守护线程有没有在运行都会随着JVM一同结束。**
>
> **因此守护线程不应该用来执行一些重要的任务或程序，因为守护线程的声明周期不可控，避免发生资源泄露或者数据不一致**
>
> 可以通过Thread类的`setDaemon(true)`方法将线程标记为守护线程

只要JVM中有普通线程在运行JVM就不会停止

**结束JVM生命周期：**
执行System.exit()

程序正常结束

程序在执行的过程中出现异常或者出错导致进程终止

操作系统出现异常导致java虚拟机进程终止

## JVM结构体系

## JDK，JRE，JVM

JDK提供了开发环境和运行环境，而运行环境就是JRE（java运行环境）,JRE中包含了JVM（java虚拟机）

JVM结构体系：

![image-20231012162932459](C:\Users\kilok\AppData\Roaming\Typora\typora-user-images\image-20231012162932459.png)

### Java类文件：.Class文件

**.java文件只有被java编译器编译为.class文件才能被JVM识别运行。**

**.class文件不是操作系统能够识别的二进制机器码，而是JVM自定义的指令集，只要对应的操作系统有对应的JVM，就能将.class文件翻译成操作系统能够识别的机器码。**

> .class文件事宜特定的二进制格式存储的，这个格式包含了Java源代码编译后的 **字节码指令，常量池，字段信息，方法信息以及其他类的结构信息**
>
> > **组成**
> >
> > **1.魔数**：.class文件开头的四个字节是一个魔数，通常为‘0xCAFEBABE’，**这用于表示这个.class文件是一个有效的java类文件**
> >
> > **2.版本信息：**紧随魔数后的两个字节是文件的版本信息，包含主版本号和次版本号，**用于标识编译器和JVM的版本兼容性**
> >
> > **3.常量池：**常量池是一个表格，包含一系列的常亮信息，如字符串的字面量，类的接口名，字段和方法的符号引用，字面常亮。**常量池用于支持字节码中的各种操作，包括字段访问，方法调用，类的初始化。**
> >
> > **4.访问标志：**表示该类的访问权限，public final abstract等等
> >
> > **5.类，父类，接口信息：**包含类的名称，父类的名称和方法的实现
> >
> > **6.字段表：**字段表包含了类的字段信息，**字段名，类型和访问标志**
> >
> > **7.方法表：**包含了类的方法信息，**方法名称，参数列表，返回类型，访问标志等**
> >
> > **8.属性表：**属性表包含了与类，字段，方法等相关的额外信息。**包括了调试信息，注解，泛型信息等**
> >
> > **9.字节码：**.class问价难道主要部分就是字节码，这是一系列字节码指令，用于定义类中方法的操作。**这些指令包括加载，储存，算术运算，方法调用，条件分支等**
> >
> > **10.异常处理表：** **异常处理表用于指定异常处理开始和结束的地方，以及异常处理的类型**
>
> .class文件是紧凑的，二进制的，它包含了类的结构和行为信息，以支持JVM的加载，验证，解析和执行。JVM解析.class文件时会按照这个结构解析和执行其中的字节码，这种设计使得只要遵循这种设计不管在哪个操作系统的JVM下都可以被解析运行。

### 类加载子系统

**类加载器是JVM中一个关键组成部分，类加载器负责将.class文件加载成可执行的字节码**

**类加载子系统的主要任务：**

> **类加载**
>
> **链接**
>
> **初始化**
>
> **验证**

#### 类加载器：

> **类加载器主要将.class文件加载到内存中，并转化为java类数据结构**
>
> 主要的类加载器：
>
> > **引导类加载器（Bootstrap Class Loader）启动类加载器，最顶层的类加载器，负责加载JDK中的核心类库**
> >
> > **扩展类加载器（Extension Class Loader）负责加载扩展的类库（依赖），默认加载java的系统路径 $JAVA_HOME中jre/lib/*.jar或者指定的jar包**
> >
> > **应用程序类加载器（Application Class Loader）系统类加载器，负责加载应用程序Classpath目录下的所有jar和.class文件**
> >
> > **除了Bootstarp Class Loader之外，其他加载器都是继承于java.lang.ClassLaoder，因为Bootstarp Class Loader底层是由C++实现，并嵌入到JVM里。当JVM启动时，BootStarp Class Loader就会启动负责加载核心库类，并加载 Extension Class Loader和Application Class Loader两个加载器**
> >
> > 以上三个加载器是java提供的加载器，我们还可以根据自己的需求自己定义加载器，但是必须继承于java.lang.ClassLoader类
>
> 类加载器的主要功能是：
>
> > **1.查找类文件**
> >
> > 当java程序需要使用到某个类时，会先检查内存中是否已经有看这个类，否则类加载器就会进行一个查找的步骤，查找对应的类文件，其中涉及到了类加载路径（Classpath）的搜索，Classpath中包含了可以加载类文件（.class）的目录（这个目录是一个指向包含类文件地址的文件夹，这些目录的结构按照包名来组织）和JRE文件（这里的JRE是压缩格式，可以包含多个类文件和资源文件）。不同的类加载器会搜索不同的位置
> >
> > **2.加载类文件**
> >
> > 当类加载器找到对应的类文件（.class文件）时会将这个.class文件加载为二进制数据，这个二进制数据就包含了对应类的字节码，字节码（一组字节组成的指令）描述着这个类的结构和行为。最后将这些二进制数据加载进内存中。
> >
> > **3.创建类对象**
> >
> > 一旦类的二进制数据加载进了内存中，那么类加载器会根据这个数据创建一个java类的对象，其中包含着这个类的所有信息（父类，接口，字段，构造方法.....）
> >
> > **4.链接**
> >
> > 在加载完类后，类加载器还会进行链接的步骤（包含验证，准备和解析）为了保证我文件的3完整性，合法性和正确性。
> >
> > > **验证：**
> > >
> > > 类加载器会验证加载出的.class文件的字节码是否符合java虚拟机（JVM）的规范
> > >
> > > 包括文件格式的验证，确认二进制结构是有效的，遵循java字节码规范
> > >
> > > 语义验证，是否符合java语言规则
> > >
> > > 字节码验证：检查字节码是否符合JVM安全规则
> > >
> > > **准备：**
> > > 在准备阶段类加载器会为静态变量分配内存，并初始化为默认值。静态变量分配内存是发生在类加载时，而不是类实例化时。
> > >
> > > **解析：**
> > >
> > > > **类或接口解析：JVM会解析类或接口的全限定名，以此来获取对应的类或接口** （类的全限定名是类的唯一标识符例如java.lang.String 是String的唯一标识符，类的权限定名的作用：在大型项目下，不同包里面可能会有相同的类名，而权限定名可以直接区分他们，同理方法的全限定名和包的全限定名）
> > >
> > > > **字段解析：解析类的字段引用，以此获得字段的内存地址**
> > >
> > > > **方法解析：解析方法引用，以此获得方法的入口**
> > >
> > > **初始化类：**
> > > 初始化类时类加载器的最后一阶段，执行类里面的构造方法，初始化类的静态字段。

### 方法区（Method Area）

**方法区是JVM内存管理中的重要一部分**

> **1.储存类信息：**
>
> java方法区会储存已经加载的类的信息，包括类名（全限定名），结构，字段，方法，构造函数，父类，接口.....，当这些信息储存在方法区，方便运行时访问和使用（这样储存类的信息就是类的符号引用，符号引用：用来描述类的结构和行为，符号引用并不会直接储存或指向一个内存地址，而是在JVM根据需要时根据符号引用查找对应的类和对应的结构，字段，方法，父类，接口...等实际运行的数据，**而且类的符号引用不是储存在字节码的具体指令，而是存储在.class文件里的元数据，描述类的结构和行为，以支持类的动态加载和运行时的解析，类的符号引用是以一种包含文本信息和结构化数据的格式存储，里面包含有类名，字段描述，方法描述，常量池索引等**）
>
> **2.静态变量：**
>
> java方法区还会储存类的静态变量，这些静态变量在被加载时就初始化了。静态变量的声明周期和类的生命周期一致。
>
> **3.**
